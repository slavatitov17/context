import { NextRequest, NextResponse } from 'next/server';
import { Mistral } from '@mistralai/mistralai';
import { readFileSync } from 'fs';
import { join } from 'path';

// Инициализация Mistral AI клиента
function getMistralClient(): Mistral | null {
  const apiKey = process.env.MISTRAL_API_KEY;
  if (!apiKey) {
    return null;
  }
  return new Mistral({ apiKey });
}

// Функция для получения контекста из документов
function getContextFromDocuments(documents: any[]): string {
  const allChunks: string[] = [];
  documents.forEach((doc: any) => {
    if (doc.chunks && Array.isArray(doc.chunks)) {
      allChunks.push(...doc.chunks);
    } else if (doc.text) {
      const chunkSize = 1000;
      for (let i = 0; i < doc.text.length; i += chunkSize) {
        allChunks.push(doc.text.substring(i, i + chunkSize));
      }
    }
  });
  return allChunks.join('\n\n---\n\n');
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { diagramType, objectDescription, documents, isFromProject } = body;

    if (!diagramType || typeof diagramType !== 'string') {
      return NextResponse.json(
        { error: 'Тип диаграммы не предоставлен' },
        { status: 400 }
      );
    }

    if (!objectDescription || typeof objectDescription !== 'string') {
      return NextResponse.json(
        { error: 'Описание объекта не предоставлено' },
        { status: 400 }
      );
    }

    // Получаем клиент Mistral AI
    const client = getMistralClient();

    if (!client) {
      return NextResponse.json(
        { error: 'Mistral AI API ключ не настроен. Установите MISTRAL_API_KEY в переменных окружения.' },
        { status: 500 }
      );
    }

    // Формируем контекст из документов (если есть)
    let context = '';
    if (isFromProject && documents && Array.isArray(documents) && documents.length > 0) {
      context = getContextFromDocuments(documents);
    }

    // Проверяем, является ли это Mermaid диаграммой
    const isMermaid = diagramType === 'MindMapMermaid' || 
                      diagramType === 'MindMapMax' ||
                      diagramType === 'SequenceMermaid' ||
                      diagramType === 'ClassMermaid' ||
                      diagramType === 'StateMermaid' ||
                      diagramType === 'ActivityMermaid' ||
                      diagramType === 'ActivityMax' ||
                      diagramType === 'GanttMermaid' ||
                      diagramType === 'ERMermaid' ||
                      diagramType === 'Architecture' ||
                      diagramType === 'C4' ||
                      diagramType === 'Git' ||
                      diagramType === 'Kanban' ||
                      diagramType === 'Pie' ||
                      diagramType === 'Quadrant' ||
                      diagramType === 'Radar' ||
                      diagramType === 'Timeline' ||
                      diagramType === 'UserJourney' ||
                      diagramType === 'XY';

    // Определяем тип Mermaid диаграммы
    const getMermaidDiagramType = (type: string): string => {
      if (type === 'MindMapMermaid' || type === 'MindMapMax') return 'mindmap';
      if (type === 'SequenceMermaid') return 'sequenceDiagram';
      if (type === 'ClassMermaid') return 'classDiagram';
      if (type === 'StateMermaid') return 'stateDiagram-v2';
      if (type === 'ActivityMermaid' || type === 'ActivityMax') return 'flowchart';
      if (type === 'GanttMermaid') return 'gantt';
      if (type === 'ERMermaid') return 'erDiagram';
      if (type === 'Architecture') return 'graph';
      if (type === 'C4') return 'C4Context';
      if (type === 'Git') return 'gitGraph';
      if (type === 'Kanban') return 'kanban';
      if (type === 'Pie') return 'pie';
      if (type === 'Quadrant') return 'quadrantChart';
      if (type === 'Radar') return 'radar';
      if (type === 'Timeline') return 'timeline';
      if (type === 'UserJourney') return 'journey';
      if (type === 'XY') return 'xychart-beta';
      return 'mindmap';
    };

    // Функция для получения детальных инструкций по синтаксису для каждого типа диаграммы
    const getMermaidSyntaxInstructions = (type: string, diagramType: string): string => {
      // Специальная расширенная инструкция для ActivityMax
      if (type === 'ActivityMax') {
        return `🚨🚨🚨 КРИТИЧЕСКИ ВАЖНО ДЛЯ ACTIVITY - ЧИТАЙ ВНИМАТЕЛЬНО! 🚨🚨🚨

ТЫ ДОЛЖЕН СОЗДАТЬ АБСОЛЮТНО ПРАВИЛЬНЫЙ КОД FLOWCHART БЕЗ ОШИБОК!

═══════════════════════════════════════════════════════════════
ПРАВИЛО #1: СИНТАКСИС - СТРОГО ОБЯЗАТЕЛЬНО!
═══════════════════════════════════════════════════════════════
- ПЕРВАЯ СТРОКА КОДА: ТОЧНО "flowchart TD" или "flowchart LR" БЕЗ ПРОБЕЛОВ, БЕЗ ОТСТУПОВ!
- НЕПРАВИЛЬНО: "  flowchart TD" или "\\n  flowchart TD" или " flowchart TD"
- ПРАВИЛЬНО: "flowchart TD" (на первой строке, без пробелов вообще!)

═══════════════════════════════════════════════════════════════
ПРАВИЛО #2: ОТСТУПЫ - ЭТО КРИТИЧНО! БЕЗ ПРАВИЛЬНЫХ ОТСТУПОВ КОД НЕ РАБОТАЕТ!
═══════════════════════════════════════════════════════════════
- ИСПОЛЬЗУЙ ТОЛЬКО ПРОБЕЛЫ! НИКОГДА НЕ ИСПОЛЬЗУЙ ТАБУЛЯЦИЮ (TAB)!
- СТРОКА 1: "flowchart TD" (0 пробелов)
- СТРОКА 2+: все узлы и стрелки с РОВНО 4 ПРОБЕЛАМИ отступа
- Для подграфов: +2 ПРОБЕЛА к базовому отступу

СТРОГАЯ СХЕМА ОТСТУПОВ:
flowchart TD                    ← 0 пробелов
    A[Начало]                   ← 4 пробела (ОБЯЗАТЕЛЬНО!)
    B{Условие?}                ← 4 пробела
    A --> B                     ← 4 пробела
    B -->|Да| C[Действие 1]     ← 4 пробела
    B -->|Нет| D[Действие 2]     ← 4 пробела

НЕПРАВИЛЬНО (вызовет ошибку!):
flowchart TD
  A[Начало]                     ← НЕТ ОТСТУПА! ОШИБКА!
    B{Условие?}                 ← Правильно
A --> B                          ← НЕТ ОТСТУПА! ОШИБКА!

═══════════════════════════════════════════════════════════════
ПРАВИЛО #3: ФОРМАТЫ УЗЛОВ - ИСПОЛЬЗУЙ ПРАВИЛЬНЫЕ!
═══════════════════════════════════════════════════════════════
- Процессы/действия: A[Текст]
- Условия/решения: B{Текст?}
- Начало/конец: C((Текст))
- Ввод/вывод: D[/Текст/] или E[\\Текст\\]

ПРАВИЛЬНО:
flowchart TD
    Start((Начало))
    Input[/Ввод данных/]
    Process[Обработка]
    Decision{Валидно?}
    Output[\\Вывод\\]
    End((Конец))

═══════════════════════════════════════════════════════════════
ПРАВИЛО #4: СТРЕЛКИ - ИСПОЛЬЗУЙ ПРАВИЛЬНЫЕ!
═══════════════════════════════════════════════════════════════
- Обычная стрелка: A --> B
- С текстом: A -->|Текст| B
- Толстая: A ==> B
- Пунктирная: A -.-> B

ПРАВИЛЬНО:
flowchart TD
    A[Действие 1]
    B{Условие?}
    C[Действие 2]
    A --> B
    B -->|Да| C
    B -->|Нет| A

═══════════════════════════════════════════════════════════════
ПРАВИЛО #5: ВСЕ СКОБКИ ДОЛЖНЫ БЫТЬ ЗАКРЫТЫ!
═══════════════════════════════════════════════════════════════
- Каждая [ должна иметь ]
- Каждая { должна иметь }
- Каждая ( должна иметь )
- Каждый subgraph должен иметь end

═══════════════════════════════════════════════════════════════
ПРАВИЛО #6: РУССКИЙ ЯЗЫК!
═══════════════════════════════════════════════════════════════
- Все названия узлов на РУССКОМ языке
- Весь текст на стрелках на РУССКОМ языке
- Синтаксис Mermaid остается на английском

═══════════════════════════════════════════════════════════════
ПРИМЕРЫ ПРАВИЛЬНОГО КОДА
═══════════════════════════════════════════════════════════════

Пример 1 (простой):
flowchart TD
    Start((Начало))
    Input[/Ввод данных/]
    Process[Обработка]
    Decision{Валидно?}
    Output[\\Вывод\\]
    End((Конец))
    
    Start --> Input
    Input --> Process
    Process --> Decision
    Decision -->|Да| Output
    Decision -->|Нет| Process
    Output --> End

Пример 2 (с подграфами):
flowchart TD
    Start((Начало))
    
    subgraph Подготовка ["Этап подготовки"]
        A1[Загрузка данных]
        A2[Валидация]
        A1 --> A2
    end
    
    subgraph Обработка ["Этап обработки"]
        B1[Обработка]
        B2[Сохранение]
        B1 --> B2
    end
    
    Start --> A1
    A2 --> B1
    B2 --> End((Конец))

═══════════════════════════════════════════════════════════════
ЧЕКЛИСТ ПЕРЕД ОТПРАВКОЙ - ПРОВЕРЬ КАЖДЫЙ ПУНКТ! 🚨
═══════════════════════════════════════════════════════════════
✅ СТРОКА 1: "flowchart TD" или "flowchart LR" БЕЗ ПРОБЕЛОВ?
✅ Все узлы имеют отступ РОВНО 4 ПРОБЕЛА?
✅ Все скобки закрыты ([], {}, ())?
✅ Все стрелки правильно оформлены (-->)?
✅ Нет специальных символов в названиях узлов?
✅ Все названия на русском языке?
✅ Все подграфы закрыты (end)?
✅ Код можно скопировать и вставить в Mermaid редактор БЕЗ ОШИБОК?

═══════════════════════════════════════════════════════════════
ЧАСТЫЕ ОШИБКИ И КАК ИХ ИЗБЕЖАТЬ
═══════════════════════════════════════════════════════════════
❌ "Syntax error in text"
   → Неправильный синтаксис, неправильные отступы, специальные символы, незакрытые скобки
   → РЕШЕНИЕ: Проверь все правила выше, особенно отступы, скобки и названия узлов

❌ "Parse error on line X"
   → Неправильный формат узла или стрелки на указанной строке
   → РЕШЕНИЕ: Проверь синтаксис узла и стрелки на этой строке, убедись что все скобки закрыты

❌ "Edge not found"
   → Стрелка ссылается на несуществующий узел
   → РЕШЕНИЕ: Убедись, что все узлы, на которые ссылаются стрелки, определены в коде

═══════════════════════════════════════════════════════════════
ФИНАЛЬНОЕ ПРЕДУПРЕЖДЕНИЕ
═══════════════════════════════════════════════════════════════
ЕСЛИ ТЫ НЕ СЛЕДУЕШЬ ЭТИМ ПРАВИЛАМ ТОЧНО - КОД НЕ БУДЕТ РАБОТАТЬ!
ПРОВЕРЬ КОД ПЕРЕД ОТПРАВКОЙ! УБЕДИСЬ, ЧТО ОТСТУПЫ ПРАВИЛЬНЫЕ!
═══════════════════════════════════════════════════════════════`;
      }
      
      // Специальная расширенная инструкция для MindMapMax
      if (type === 'MindMapMax') {
        return `🚨🚨🚨 КРИТИЧЕСКИ ВАЖНО ДЛЯ MINDMAP - ЧИТАЙ ВНИМАТЕЛЬНО! 🚨🚨🚨

ТЫ ДОЛЖЕН СОЗДАТЬ АБСОЛЮТНО ПРАВИЛЬНЫЙ КОД MINDMAP БЕЗ ОШИБОК!

═══════════════════════════════════════════════════════════════
ПРАВИЛО #1: СИНТАКСИС - СТРОГО ОБЯЗАТЕЛЬНО!
═══════════════════════════════════════════════════════════════
- ПЕРВАЯ СТРОКА КОДА: ТОЧНО "mindmap" БЕЗ ПРОБЕЛОВ, БЕЗ ОТСТУПОВ!
- НЕПРАВИЛЬНО: "  mindmap" или "\\n  mindmap" или " mindmap"
- ПРАВИЛЬНО: "mindmap" (на первой строке, без пробелов вообще!)

═══════════════════════════════════════════════════════════════
ПРАВИЛО #2: ОТСТУПЫ - ЭТО КРИТИЧНО! БЕЗ ПРАВИЛЬНЫХ ОТСТУПОВ КОД НЕ РАБОТАЕТ!
═══════════════════════════════════════════════════════════════
- ИСПОЛЬЗУЙ ТОЛЬКО ПРОБЕЛЫ! НИКОГДА НЕ ИСПОЛЬЗУЙ ТАБУЛЯЦИЮ (TAB)!
- СТРОКА 1: "mindmap" (0 пробелов)
- СТРОКА 2: корневой узел с РОВНО 2 ПРОБЕЛАМИ отступа
- СТРОКА 3+: каждый следующий уровень = +2 ПРОБЕЛА от предыдущего

СТРОГАЯ СХЕМА ОТСТУПОВ:
mindmap                    ← 0 пробелов
  root((Корневой узел))    ← 2 пробела (ОБЯЗАТЕЛЬНО!)
    Подтема 1              ← 4 пробела (2+2)
      Деталь 1.1           ← 6 пробелов (4+2)
        Поддеталь 1.1.1    ← 8 пробелов (6+2)
      Деталь 1.2           ← 6 пробелов (возврат на уровень)
    Подтема 2              ← 4 пробела (возврат на уровень)

НЕПРАВИЛЬНО (вызовет ошибку!):
mindmap
root((Корневой узел))      ← НЕТ ОТСТУПА! ОШИБКА!
  Подтема 1                ← Правильно
Подтема 2                   ← НЕТ ОТСТУПА! ОШИБКА "No parent could be found"!

═══════════════════════════════════════════════════════════════
ПРАВИЛО #3: КОРНЕВОЙ УЗЕЛ - ТОЛЬКО ОДИН! БЕЗ ИСКЛЮЧЕНИЙ!
═══════════════════════════════════════════════════════════════
- В MindMap МОЖЕТ БЫТЬ ТОЛЬКО ОДИН корневой узел!
- Корневой узел ОБЯЗАТЕЛЬНО на второй строке с отступом РОВНО 2 ПРОБЕЛА
- Формат: "  root((Название))" или просто "  Название"
- Если в описании несколько основных тем → выбери ОДНУ главную как корневой узел, остальные сделай подтемами первого уровня (4 пробела)

НЕПРАВИЛЬНО (вызовет ошибку "There can be only one root"):
mindmap
  root((Тема 1))
  root((Тема 2))            ← ОШИБКА! Два корневых узла!

ПРАВИЛЬНО:
mindmap
  root((Главная тема))
    Тема 1                  ← Подтема первого уровня (4 пробела)
    Тема 2                  ← Подтема первого уровня (4 пробела)

═══════════════════════════════════════════════════════════════
ПРАВИЛО #4: ИЕРАРХИЯ - КАЖДЫЙ УЗЕЛ ДОЛЖЕН ИМЕТЬ РОДИТЕЛЯ!
═══════════════════════════════════════════════════════════════
- Корневой узел (2 пробела) - единственный без родителя
- Все остальные узлы ДОЛЖНЫ иметь отступ БОЛЬШЕ 2 пробелов
- Если узел имеет отступ 2 пробела и это НЕ корневой узел → ОШИБКА!
- Ошибка "No parent could be found for X" означает, что узел X имеет неправильный отступ

═══════════════════════════════════════════════════════════════
ПРАВИЛО #5: НАЗВАНИЯ УЗЛОВ
═══════════════════════════════════════════════════════════════
- НЕ используй кавычки: "Название" → НЕПРАВИЛЬНО
- НЕ используй скобки (кроме двойных для корневого узла)
- Можно: буквы, цифры, пробелы, дефисы, подчеркивания
- Все названия на РУССКОМ языке

═══════════════════════════════════════════════════════════════
ПРИМЕРЫ ПРАВИЛЬНОГО КОДА (КОПИРУЙ СТРУКТУРУ!)
═══════════════════════════════════════════════════════════════

Пример 1 (простой):
mindmap
  root((Управление проектом))
    Планирование
      Задачи
      Ресурсы
    Реализация
      Разработка
      Тестирование

Пример 2 (сложный - как в твоем случае):
mindmap
  root((СМК МП))
    Внешние факторы
      Факторы производства
      Внешние заинтересованные стороны
      Рынок
      Требования
      Общество
      Опасные производственные объекты
    Внутренние факторы
      Документированная информация
      Процессная модель СМК
      Мониторинг, измерения, анализ и оценка
      Результативность функционирования процессов СМК
      Производственный контроль за соблюдением требований промышленной безопасности
      Экспертиза промышленной безопасности
      Цифровизация процессов мониторинга, измерения, анализа и оценки
      Активы компании
      Внутренние заинтересованные стороны
    Цели СМК

═══════════════════════════════════════════════════════════════
ЧЕКЛИСТ ПЕРЕД ОТПРАВКОЙ - ПРОВЕРЬ КАЖДЫЙ ПУНКТ! 🚨
═══════════════════════════════════════════════════════════════
✅ СТРОКА 1: "mindmap" БЕЗ ПРОБЕЛОВ?
✅ СТРОКА 2: корневой узел с РОВНО 2 ПРОБЕЛАМИ?
✅ ТОЛЬКО ОДИН узел с отступом 2 пробела (корневой)?
✅ Все остальные узлы имеют отступы 4, 6, 8... (кратные 2, но >= 4)?
✅ Каждый узел (кроме корневого) имеет родителя?
✅ Нет кавычек в названиях узлов?
✅ Все названия на русском языке?
✅ Код можно скопировать и вставить в Mermaid редактор БЕЗ ОШИБОК?

═══════════════════════════════════════════════════════════════
ЧАСТЫЕ ОШИБКИ И КАК ИХ ИЗБЕЖАТЬ
═══════════════════════════════════════════════════════════════
❌ "There can be only one root" 
   → У тебя несколько узлов с отступом 2 пробела
   → РЕШЕНИЕ: Оставь только ОДИН корневой узел (2 пробела), остальные сделай подтемами (4 пробела)

❌ "No parent could be found for X"
   → Узел X имеет отступ 2 пробела, но это не корневой узел
   → РЕШЕНИЕ: Увеличь отступ узла X до 4+ пробелов

❌ "Syntax error"
   → Неправильный синтаксис, специальные символы, неправильные отступы
   → РЕШЕНИЕ: Проверь все правила выше

═══════════════════════════════════════════════════════════════
ФИНАЛЬНОЕ ПРЕДУПРЕЖДЕНИЕ
═══════════════════════════════════════════════════════════════
ЕСЛИ ТЫ НЕ СЛЕДУЕШЬ ЭТИМ ПРАВИЛАМ ТОЧНО - КОД НЕ БУДЕТ РАБОТАТЬ!
ПРОВЕРЬ КОД ПЕРЕД ОТПРАВКОЙ! УБЕДИСЬ, ЧТО ОТСТУПЫ ПРАВИЛЬНЫЕ!
═══════════════════════════════════════════════════════════════`;
      }

      const instructions: Record<string, string> = {
        'MindMapMermaid': `ДЛЯ MERMAID MINDMAP (${diagramType}):
- Начинай с "mindmap"
- Используй отступы (2 пробела) для создания иерархии
- Формат: mindmap\\n  root((Корневой узел))\\n    Подтема 1\\n      Деталь 1.1\\n    Подтема 2
- Корневой узел можно обозначить как root((Название)) или просто как первый элемент
- Каждый уровень иерархии должен иметь правильный отступ (2 пробела на уровень)
- НЕ используй специальные символы в названиях узлов, которые могут сломать синтаксис`,

        'SequenceMermaid': `ДЛЯ MERMAID SEQUENCE (${diagramType}):
- Начинай с "sequenceDiagram"
- Используй participant для определения участников: participant Название
- Используй стрелки для сообщений: Название1->>Название2: Сообщение
- Типы стрелок: -> (сплошная), --> (пунктирная), ->> (сплошная с наконечником), -->> (пунктирная с наконечником)
- Можно использовать активацию: activate Название и deactivate Название
- Пример: sequenceDiagram\\n    participant A as Участник1\\n    participant B as Участник2\\n    A->>B: Сообщение`,

        'ClassMermaid': `ДЛЯ MERMAID CLASS (${diagramType}):
- Начинай с "classDiagram"
- Определяй классы: class НазваниеКласса
- Добавляй атрибуты: НазваниеКласса : +атрибут
- Добавляй методы: НазваниеКласса : +метод()
- Используй отношения: Название1 --> Название2 (ассоциация), Название1 <|-- Название2 (наследование)
- Типы отношений: --> (ассоциация), <|-- (наследование), *-- (композиция), o-- (агрегация)
- Пример: classDiagram\\n    class Класс1\\n    class Класс2\\n    Класс1 --> Класс2`,

        'StateMermaid': `ДЛЯ MERMAID STATE (${diagramType}):
- Начинай с "stateDiagram-v2" (обязательно v2!)
- Определяй состояния: state НазваниеСостояния
- Используй переходы: Название1 --> Название2 : Событие
- Можно использовать составные состояния: state Составное {\\n    Состояние1\\n    Состояние2\\n}
- Пример: stateDiagram-v2\\n    [*] --> Состояние1\\n    Состояние1 --> Состояние2 : Событие`,

        'ActivityMermaid': `ДЛЯ MERMAID ACTIVITY (${diagramType}):
- Начинай с "flowchart TD" (сверху вниз) или "flowchart LR" (слева направо)
- Используй узлы: Название[Текст] (прямоугольник), Название{Условие} (ромб), Название((Круг))
- Используй стрелки: Название1 --> Название2
- Форматы узлов: [Текст] (прямоугольник), {Условие} (ромб), ((Круг)), (Скругленный)
- Пример: flowchart TD\\n    A[Начало] --> B{Условие?}\\n    B -->|Да| C[Действие1]\\n    B -->|Нет| D[Действие2]`,
        'ActivityMax': `ДЛЯ MERMAID ACTIVITY MAX (${diagramType}):
- См. детальные инструкции выше (специальная обработка для ActivityMax)`,

        'GanttMermaid': `ДЛЯ MERMAID GANTT (${diagramType}):
- Начинай с "gantt"
- Добавляй заголовок: title Название проекта
- Определяй формат даты: dateFormat YYYY-MM-DD
- Добавляй секции: section Название секции
- Добавляй задачи: Название задачи :done, Название, Дата начала, Длительность
- Статусы: :done (выполнено), :active (активно), :crit (критично), :milestone (веха)
- Пример: gantt\\n    title Проект\\n    dateFormat YYYY-MM-DD\\n    section Секция1\\n    Задача1 :done, 2024-01-01, 5d`,

        'ERMermaid': `ДЛЯ MERMAID ER (${diagramType}):
- Начинай с "erDiagram"
- Определяй сущности: НазваниеСущности {\\n    тип поле\\n    тип поле2\\n}
- Используй отношения: Сущность1 ||--|| Сущность2 (один к одному), Сущность1 }o--|| Сущность2 (многие к одному)
- Типы отношений: ||--|| (один к одному), }o--|| (многие к одному), ||--o{ (один ко многим), }o--o{ (многие ко многим)
- Пример: erDiagram\\n    СУЩНОСТЬ1 {\\n        int id\\n        string название\\n    }\\n    СУЩНОСТЬ1 ||--|| СУЩНОСТЬ2`,

        'Architecture': `ДЛЯ ARCHITECTURE (${diagramType}):
- Начинай с "graph TD" (сверху вниз) или "graph LR" (слева направо)
- Используй узлы для компонентов: Название[Компонент]
- Используй стрелки для связей: Название1 --> Название2
- Можно использовать подграфы: subgraph Название\\n    Узел1\\n    Узел2\\n    end
- Форматы узлов: [Текст] (прямоугольник), {Текст} (ромб), ((Текст)) (круг)
- Пример: graph TD\\n    A[Компонент1] --> B[Компонент2]\\n    B --> C[Компонент3]`,

        'C4': `ДЛЯ C4 (${diagramType}):
- Начинай с "C4Context" для контекстной диаграммы
- Используй Person для людей: Person(alias, "Название", "Описание")
- Используй System для систем: System(alias, "Название", "Описание")
- Используй SystemDb для баз данных: SystemDb(alias, "Название", "Описание")
- Используй Rel для связей: Rel(откуда, куда, "Связь", "Технология")
- Все параметры в кавычках должны быть на русском
- Пример: C4Context\\n    Person(user, "Пользователь", "Использует систему")\\n    System(system, "Веб-система", "Основная система")\\n    Rel(user, system, "Использует", "HTTPS")`,

        'Git': `ДЛЯ GIT (${diagramType}):
- Начинай с "gitGraph"
- Используй commit для коммитов: commit id: "Название коммита"
- Используй branch для веток: branch название_ветки
- Используй checkout для переключения: checkout название_ветки
- Используй merge для слияния: merge название_ветки
- Названия коммитов в кавычках должны быть на русском
- Пример: gitGraph\\n    commit id: "Первый коммит"\\n    branch develop\\n    checkout develop\\n    commit id: "Коммит в develop"\\n    checkout main\\n    merge develop`,

        'Kanban': `ДЛЯ KANBAN (${diagramType}):
- Начинай с "kanban"
- Определяй колонки: section Название колонки
- Добавляй задачи в колонки: Название задачи
- Можно использовать статусы: Название задачи :done (выполнено), :active (активно), :crit (критично)
- Названия колонок и задач должны быть на русском
- Пример: kanban\\n    section Сделать\\n    Задача 1\\n    Задача 2 :active\\n    section В работе\\n    Задача 3\\n    section Готово\\n    Задача 4 :done`,

        'Pie': `ДЛЯ PIE (${diagramType}):
- Начинай с "pie"
- Добавляй заголовок: title "Название диаграммы" (заголовок в кавычках)
- Определяй доли: "Название" : значение
- Значения должны быть числами (без кавычек)
- Названия элементов в кавычках должны быть на русском
- Пример: pie title "Распределение"\\n    "Элемент1" : 30\\n    "Элемент2" : 50\\n    "Элемент3" : 20`,

        'Quadrant': `ДЛЯ QUADRANT (${diagramType}):
- Начинай с "quadrantChart"
- Определяй оси: x-axis Название1 --> Название2
- Определяй квадранты: quadrant Название квадранта
- Добавляй точки: Название точки: [x, y]
- Пример: quadrantChart\\n    x-axis Низкий --> Высокий\\n    y-axis Низкий --> Высокий\\n    quadrant Q1\\n    Точка1: [0.5, 0.5]`,

        'Radar': `ДЛЯ RADAR (${diagramType}):
- Начинай с "radar"
- Определяй оси: x-axis Название оси
- Добавляй серии данных: Название серии --> значение1, значение2, значение3
- Количество значений должно соответствовать количеству осей
- Пример: radar\\n    x-axis Ось1, Ось2, Ось3\\n    Серия1 --> 5, 3, 4\\n    Серия2 --> 2, 4, 3`,

        'Timeline': `ДЛЯ TIMELINE (${diagramType}):
- Начинай с "timeline"
- Определяй события: title Название события
- Можно группировать по периодам: section Период\\n    Событие1 : Событие2
- Пример: timeline\\n    title История\\n    section Период1\\n    Событие1 : Событие2\\n    section Период2\\n    Событие3`,

        'UserJourney': `ДЛЯ USER JOURNEY (${diagramType}):
- Начинай с "journey"
- Определяй этапы: title Название этапа : оценка
- Оценки: 0-5 (0 - очень плохо, 5 - отлично)
- Можно использовать несколько этапов подряд
- Пример: journey\\n    title Пользовательский путь\\n    Этап1 : 5\\n    Этап2 : 3\\n    Этап3 : 4`,

        'XY': `ДЛЯ XY (${diagramType}):
- Начинай с "xychart-beta"
- Определяй оси: x-axis [значение1, значение2, ...] или x-axis [min..max]
- Определяй серии: line [значение1, значение2, ...] или bar [значение1, значение2, ...]
- Количество значений в серии должно соответствовать количеству точек на оси X
- Пример: xychart-beta\\n    x-axis [1, 2, 3, 4, 5]\\n    y-axis [0, 100]\\n    line [10, 20, 30, 40, 50]`
      };

      return instructions[type] || '';
    };

    const mermaidDiagramType = isMermaid ? getMermaidDiagramType(diagramType) : '';

    // Формируем промпт для генерации кода
    const systemPrompt = isMermaid 
      ? `Ты эксперт по созданию диаграмм в формате Mermaid. Твоя задача - создать КОРРЕКТНЫЙ и ВАЛИДНЫЙ код Mermaid для ${mermaidDiagramType} диаграммы, который БЕЗ ОШИБОК отрендерится в Mermaid.

КРИТИЧЕСКИ ВАЖНО:
1. Генерируй ТОЛЬКО валидный код Mermaid, который может быть успешно отрендерен
2. Код ДОЛЖЕН начинаться с правильного типа диаграммы (${mermaidDiagramType}) - это ОБЯЗАТЕЛЬНО
3. Используй СТРОГО правильный синтаксис Mermaid для указанного типа диаграммы согласно официальной документации
4. ВСЕ НАЗВАНИЯ УЗЛОВ, КЛАССОВ, СОСТОЯНИЙ И ДРУГИХ ЭЛЕМЕНТОВ ДОЛЖНЫ БЫТЬ НА РУССКОМ ЯЗЫКЕ
5. Используй русские названия для всех элементов (например: "Институт", "Студент", "Преподаватель")
6. Синтаксис Mermaid остается на английском (classDiagram, sequenceDiagram, etc.), но содержимое - на русском
7. ПРОВЕРЬ код перед отправкой: все скобки закрыты, правильные разделители, правильное количество элементов
8. НЕ используй специальные символы в названиях, которые могут сломать синтаксис (кавычки внутри названий узлов, незакрытые скобки)
9. После кода диаграммы, добавь глоссарий в формате JSON массива объектов с полями "element" и "description"
10. Если сомневаешься в синтаксисе - используй простые конструкции, которые точно работают`
      : `Ты эксперт по созданию диаграмм в формате PlantUML. Твоя задача - создать корректный код PlantUML для указанного типа диаграммы.

КРИТИЧЕСКИ ВАЖНО:
1. Генерируй только валидный код PlantUML, без дополнительных объяснений
2. Код должен начинаться с ${diagramType === 'MindMapPlantUML' ? '@startmindmap' : '@startuml'} и заканчиваться ${diagramType === 'MindMapPlantUML' ? '@endmindmap' : '@enduml'}
3. Используй правильный синтаксис для указанного типа диаграммы (английские ключевые слова: class, interface, component, etc.)
4. ВСЕ НАЗВАНИЯ ОБЪЕКТОВ, КЛАССОВ, МЕТОДОВ, АТРИБУТОВ И ДРУГИХ ЭЛЕМЕНТОВ ДОЛЖНЫ БЫТЬ НА РУССКОМ ЯЗЫКЕ
5. Используй русские названия для всех сущностей в диаграмме (например: "Институт" вместо "Institute", "Студент" вместо "Student")
6. Синтаксис PlantUML остается на английском (class, interface, ->, etc.), но содержимое - на русском
7. После кода диаграммы, добавь глоссарий в формате JSON массива объектов с полями "element" и "description"`;

    const diagramTypeDescriptions: Record<string, string> = {
      'UseCase': 'UML диаграмма прецедентов (Use Case Diagram)',
      'Object': 'UML диаграмма объектов (Object Diagram)',
      'SequenceMermaid': 'Sequence диаграмма (Mermaid)',
      'ClassMermaid': 'Class диаграмма (Mermaid)',
      'StateMermaid': 'State диаграмма (Mermaid)',
      'ActivityMermaid': 'Activity диаграмма (Mermaid)',
      'GanttMermaid': 'Gantt диаграмма (Mermaid)',
      'ERMermaid': 'ER диаграмма (Mermaid)',
      'MindMapMermaid': 'MindMap диаграмма (Mermaid)',
      'MindMapMax': 'MindMap диаграмма (Mermaid) - Максимально качественная версия',
      'MindMapPlantUML': 'MindMap диаграмма (PlantUML) - Максимально качественная версия',
      'ActivityMax': 'Activity диаграмма (Mermaid) - Максимально качественная версия',
      'Sequence': 'UML диаграмма последовательности (Sequence Diagram)',
      'Class': 'UML диаграмма классов (Class Diagram)',
      'State': 'UML диаграмма состояний (State Diagram)',
      'Activity': 'UML диаграмма активности (Activity Diagram)',
      'Gantt': 'Диаграмма Ганта (Gantt Chart)',
      'ER': 'ER диаграмма (Entity-Relationship Diagram)',
      'MindMap': 'Интеллект-карта (Mind Map)',
      'Architecture': 'Architecture диаграмма (Mermaid)',
      'C4': 'C4 диаграмма (Mermaid)',
      'Git': 'Git диаграмма (Mermaid)',
      'Kanban': 'Kanban диаграмма (Mermaid)',
      'Pie': 'Pie диаграмма (Mermaid)',
      'Quadrant': 'Quadrant диаграмма (Mermaid)',
      'Radar': 'Radar диаграмма (Mermaid)',
      'Timeline': 'Timeline диаграмма (Mermaid)',
      'UserJourney': 'User Journey диаграмма (Mermaid)',
      'XY': 'XY диаграмма (Mermaid)',
    };

    const typeDescription = diagramTypeDescriptions[diagramType] || diagramType;

    let userPrompt = '';
    
    if (isMermaid) {
      // Получаем детальные инструкции по синтаксису для данного типа диаграммы
      const syntaxInstructions = getMermaidSyntaxInstructions(diagramType, mermaidDiagramType);
      
      userPrompt = `Создай ${typeDescription} для следующего объекта/процесса:

${objectDescription}

КРИТИЧЕСКИ ВАЖНО:
1. Все названия узлов, классов, состояний и других элементов должны быть на русском языке
2. Используй русские названия для всех элементов (например: "Институт", "Студент", "Преподаватель", "Курс" и т.д.)
3. Синтаксис Mermaid остается на английском (${mermaidDiagramType}, classDiagram, sequenceDiagram, etc.), но содержимое - на русском
4. СТРОГО следуй синтаксису Mermaid для типа ${mermaidDiagramType}
5. Проверь, что код валидный и может быть отрендерен без ошибок
6. НЕ используй специальные символы в названиях, которые могут сломать синтаксис (например: кавычки, скобки в неправильных местах)
7. Используй правильные отступы и форматирование

${syntaxInstructions}

ПРИМЕРЫ ПРАВИЛЬНОГО СИНТАКСИСА:
- Всегда начинай с правильного ключевого слова типа диаграммы
- Используй правильные разделители и синтаксические конструкции
- Проверь соответствие количества элементов (например, в Radar количество значений должно соответствовать количеству осей)
- Убедись, что все скобки, кавычки и другие символы правильно закрыты`;

      if (context) {
        userPrompt += `\n\nДополнительный контекст из документов:\n${context.substring(0, 3000)}`;
      }

      userPrompt += `\n\nСгенерируй код Mermaid и глоссарий. Формат ответа:
\`\`\`mermaid
${mermaidDiagramType}
[код диаграммы с русскими названиями элементов - ОБЯЗАТЕЛЬНО валидный синтаксис Mermaid]
\`\`\`

${diagramType === 'ActivityMax' ? `🚨🚨🚨 КРИТИЧЕСКИ ВАЖНО ДЛЯ ACTIVITY MAX! 🚨🚨🚨

ПЕРЕД ОТПРАВКОЙ КОДА ОБЯЗАТЕЛЬНО ПРОВЕРЬ:

1. ✅ ПЕРВАЯ СТРОКА: точно "flowchart TD" или "flowchart LR" БЕЗ ПРОБЕЛОВ?
2. ✅ Все узлы имеют отступ РОВНО 4 ПРОБЕЛА?
3. ✅ Все скобки закрыты ([], {}, ())?
4. ✅ Все стрелки правильно оформлены (-->)?
5. ✅ Нет узлов без отступов?
6. ✅ Все названия на русском языке?
7. ✅ Все подграфы закрыты (end)?

ЕСЛИ ХОТЬ ОДИН ПУНКТ НЕ ВЫПОЛНЕН - ИСПРАВЬ КОД ПЕРЕД ОТПРАВКОЙ!

ПРИМЕР ПРАВИЛЬНОГО КОДА:
flowchart TD
    Start((Начало))
    Input[/Ввод данных/]
    Process[Обработка]
    Decision{Валидно?}
    Output[\\Вывод\\]
    End((Конец))
    
    Start --> Input
    Input --> Process
    Process --> Decision
    Decision -->|Да| Output
    Decision -->|Нет| Process
    Output --> End

ОБРАТИ ВНИМАНИЕ НА ОТСТУПЫ:
- Строка 1: 0 пробелов (flowchart TD)
- Строка 2+: 4 пробела (все узлы и стрелки)

НЕ ОТПРАВЛЯЙ КОД, ЕСЛИ НЕ УВЕРЕН В ОТСТУПАХ!` : diagramType === 'MindMapMax' ? `🚨🚨🚨 КРИТИЧЕСКИ ВАЖНО ДЛЯ MINDMAP MAX! 🚨🚨🚨

ПЕРЕД ОТПРАВКОЙ КОДА ОБЯЗАТЕЛЬНО ПРОВЕРЬ:

1. ✅ ПЕРВАЯ СТРОКА: точно "mindmap" БЕЗ ПРОБЕЛОВ?
2. ✅ ВТОРАЯ СТРОКА: корневой узел с РОВНО 2 ПРОБЕЛАМИ отступа?
3. ✅ ТОЛЬКО ОДИН узел с отступом 2 пробела (корневой)?
4. ✅ Все остальные узлы имеют отступы 4, 6, 8... (>= 4, кратные 2)?
5. ✅ Нет узлов с отступом 2 пробела, кроме корневого?
6. ✅ Каждый узел (кроме корневого) имеет родителя?
7. ✅ Нет кавычек в названиях узлов?
8. ✅ Все названия на русском языке?

ЕСЛИ ХОТЬ ОДИН ПУНКТ НЕ ВЫПОЛНЕН - ИСПРАВЬ КОД ПЕРЕД ОТПРАВКОЙ!

ПРИМЕР ПРАВИЛЬНОГО КОДА:
mindmap
  root((СМК МП))
    Внешние факторы
      Факторы производства
      Рынок
    Внутренние факторы
      Документированная информация
      Процессная модель СМК

ОБРАТИ ВНИМАНИЕ НА ОТСТУПЫ:
- Строка 1: 0 пробелов (mindmap)
- Строка 2: 2 пробела (корневой узел)
- Строка 3+: 4+ пробелов (подтемы)

НЕ ОТПРАВЛЯЙ КОД, ЕСЛИ НЕ УВЕРЕН В ОТСТУПАХ!` : `ВАЖНО ПЕРЕД ОТПРАВКОЙ:
- Проверь, что код начинается с правильного ключевого слова (${mermaidDiagramType})
- Убедись, что все синтаксические конструкции правильные
- Проверь, что нет незакрытых скобок, кавычек или других символов
- Убедись, что количество элементов соответствует требованиям типа диаграммы
- Код должен быть готов к рендерингу без ошибок`}

\`\`\`json
[
  {"element": "Название элемента на русском", "description": "Описание элемента на русском"},
  ...
]
\`\`\``;
    } else {
      // Загружаем инструкции для MindMapPlantUML из файла
      let plantUmlInstructions = '';
      if (diagramType === 'MindMapPlantUML') {
        try {
          const instructionsPath = join(process.cwd(), 'prompts', 'mindmap-plantuml-instructions.md');
          plantUmlInstructions = readFileSync(instructionsPath, 'utf-8');
        } catch (error) {
          console.error('Ошибка при чтении инструкций для MindMapPlantUML:', error);
          plantUmlInstructions = 'ДЛЯ MINDMAP PLANTUML: Используй правильный синтаксис @startmindmap ... @endmindmap. Структура: * Центральная тема ** Подтема 1 *** Подподтема 1.1 ** Подтема 2. ОБЯЗАТЕЛЬНО добавляй стили для строгих цветов (белый, черный, серый)!';
        }
      }

      userPrompt = `Создай ${typeDescription} для следующего объекта/процесса:

${objectDescription}

ВАЖНО: Все названия объектов, классов, методов, атрибутов и других элементов должны быть на русском языке. Используй русские названия для всех сущностей (например: "Институт", "Студент", "Преподаватель", "Курс" и т.д.). Синтаксис PlantUML остается на английском (class, interface, ->, etc.), но содержимое - на русском.

${diagramType === 'MindMapPlantUML' ? plantUmlInstructions : ''}
${diagramType === 'MindMap' ? 'ДЛЯ MINDMAP: Используй правильный синтаксис @startmindmap ... @endmindmap. Структура: * Центральная тема ** Подтема 1 *** Подподтема 1.1 ** Подтема 2. НЕ используй просто "mindmap" без @startmindmap/@endmindmap!' : ''}
${diagramType === 'Activity' ? 'ДЛЯ ACTIVITY: Используй правильный синтаксис activity диаграммы: start, :действие;, if (условие) then, else, endif, fork, fork again, end fork, stop. НЕ используй split/join, используй fork/fork again/end fork!' : ''}
${diagramType === 'Class' ? 'ДЛЯ CLASS: Для длинных русских названий классов используй пробелы или разбивай на несколько слов. Например: "Федеральное Государственное Образовательное Учреждение" вместо "ФедеральноеГосударственноеОбразовательноеУчреждение". Используй кавычки для названий с пробелами: class "Название с пробелами" as Алиас' : ''}`;

      if (context) {
        userPrompt += `\n\nДополнительный контекст из документов:\n${context.substring(0, 3000)}`;
      }

      userPrompt += `\n\nСгенерируй код PlantUML и глоссарий. Формат ответа:
\`\`\`plantuml
${diagramType === 'MindMapPlantUML' ? '@startmindmap' : '@startuml'}
[код диаграммы с русскими названиями объектов]
${diagramType === 'MindMapPlantUML' ? '@endmindmap' : '@enduml'}
\`\`\`

\`\`\`json
[
  {"element": "Название элемента на русском", "description": "Описание элемента на русском"},
  ...
]
\`\`\``;
    }

    try {
      // Вызываем модель Mistral AI
      const chatResponse = await client.chat.complete({
        model: 'pixtral-12b-2409',
        messages: [
          {
            role: 'system',
            content: systemPrompt,
          },
          {
            role: 'user',
            content: userPrompt,
          },
        ],
        maxTokens: 4096,
        temperature: 0.3, // Низкая температура для более точного кода
      });

      const responseContent = chatResponse.choices?.[0]?.message?.content;
      let responseText = '';
      if (typeof responseContent === 'string') {
        responseText = responseContent;
      } else if (Array.isArray(responseContent)) {
        responseText = responseContent
          .map(c => {
            if (typeof c === 'string') return c;
            if ('text' in c && typeof (c as any).text === 'string') return (c as any).text;
            return '';
          })
          .join('');
      } else {
        responseText = String(responseContent || '');
      }

      // Специальная функция для исправления отступов в MindMap
      const fixMindMapIndentation = (code: string): string => {
        const lines = code.split('\n').map(l => l.trimEnd());
        if (lines.length === 0) return 'mindmap\n  root((Корневой узел))';
        
        const result: string[] = [];
        
        // Первая строка должна быть "mindmap" без отступов
        const firstLine = lines[0].trim();
        if (firstLine.toLowerCase() === 'mindmap' || firstLine === '') {
          result.push('mindmap');
        } else {
          result.push('mindmap');
          // Если первая строка не "mindmap", добавляем ее как корневой узел
          if (firstLine) {
            const rootContent = firstLine.replace(/^root\(\(|\)\)$/g, '').trim();
            result.push(`  root((${rootContent || 'Корневой узел'}))`);
          }
        }
        
        // Находим корневой узел
        let rootFound = false;
        let rootContent = '';
        let startIndex = 1;
        
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          
          if (line.startsWith('root')) {
            rootContent = line.replace(/^root\(\(|\)\)$/g, '').trim();
            rootFound = true;
            startIndex = i + 1;
            break;
          } else if (!rootFound) {
            // Первая непустая строка после mindmap - это корневой узел
            rootContent = line.replace(/^root\(\(|\)\)$/g, '').trim();
            rootFound = true;
            startIndex = i + 1;
            break;
          }
        }
        
        // Добавляем корневой узел
        if (rootFound && rootContent) {
          result.push(`  root((${rootContent}))`);
        } else if (!rootFound) {
          result.push('  root((Корневой узел))');
        }
        
        // Обрабатываем остальные строки - все они должны быть подтемами (>= 4 пробела)
        const contentLines: string[] = [];
        for (let i = startIndex; i < lines.length; i++) {
          const line = lines[i].trim();
          if (line && !line.startsWith('root')) {
            contentLines.push(line);
          }
        }
        
        // Если есть строки без отступов или с маленькими отступами - это первый уровень (4 пробела)
        // Если есть строки с большими отступами - сохраняем относительную структуру
        let baseIndent = 4;
        for (const line of contentLines) {
          const originalLine = lines.find(l => l.trim() === line);
          if (originalLine) {
            const leadingSpaces = originalLine.length - originalLine.trimStart().length;
            if (leadingSpaces <= 2) {
              // Строка без отступа или с маленьким отступом - это первый уровень
              result.push(`    ${line}`);
            } else {
              // Сохраняем относительный отступ, но нормализуем
              // Минимум 4 пробела, кратно 2
              const normalizedIndent = Math.max(4, Math.ceil((leadingSpaces - 2) / 2) * 2 + 2);
              result.push(' '.repeat(normalizedIndent) + line);
            }
          } else {
            // Если не нашли оригинальную строку, добавляем с базовым отступом
            result.push(' '.repeat(baseIndent) + line);
          }
        }
        
        return result.join('\n');
      };

      // Функция для постобработки и исправления кода Mermaid
      const fixMermaidCode = (code: string, diagramType: string): string => {
        let fixed = code.trim();
        
        // Специальная обработка для MindMap
        if (diagramType === 'mindmap') {
          // Удаляем все отступы в начале и нормализуем
          const lines = fixed.split('\n');
          const normalized: string[] = [];
          
          for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue;
            
            if (i === 0) {
              // Первая строка должна быть "mindmap"
              normalized.push('mindmap');
            } else if (i === 1) {
              // Вторая строка - корневой узел с отступом 2 пробела
              if (line.startsWith('root')) {
                normalized.push(`  ${line}`);
              } else {
                normalized.push(`  root((${line.replace(/^root\(\(|\)\)$/g, '')}))`);
              }
            } else {
              // Остальные строки - определяем уровень по позиции
              const prevLine = normalized[normalized.length - 1];
              const prevIndent = prevLine.length - prevLine.trimStart().length;
              
              // Если текущая строка без отступа или с маленьким отступом - это первый уровень (4 пробела)
              const leadingSpaces = lines[i].length - lines[i].trimStart().length;
              if (leadingSpaces <= 2) {
                normalized.push(`    ${line}`); // 4 пробела
              } else {
                // Сохраняем относительный отступ, но нормализуем до четных чисел
                const normalizedIndent = Math.max(4, Math.ceil((leadingSpaces - 2) / 2) * 2 + 2);
                normalized.push(' '.repeat(normalizedIndent) + line);
              }
            }
          }
          
          fixed = normalized.join('\n');
        } else {
          // Для других типов диаграмм
          // Убеждаемся, что код начинается с правильного типа диаграммы
          if (!fixed.startsWith(diagramType)) {
            // Удаляем возможные префиксы и добавляем правильный
            fixed = fixed.replace(/^(flowchart|graph|mindmap|sequenceDiagram|classDiagram|stateDiagram|erDiagram|gantt|pie|quadrantChart|radar|timeline|journey|xychart|gitGraph|kanban|C4Context|C4Container)\s*/i, '');
            fixed = `${diagramType}\n${fixed}`;
          }
          
          // Исправляем распространенные ошибки
          // Удаляем лишние пробелы в начале строк
          fixed = fixed.split('\n').map(line => line.trimStart()).join('\n');
          
          // Исправляем незакрытые скобки в flowchart/graph (добавляем закрывающие скобки для узлов)
          if (diagramType.startsWith('flowchart') || diagramType.startsWith('graph')) {
            // Убеждаемся, что узлы правильно закрыты
            fixed = fixed.replace(/(\[[^\]]*)$/gm, (match) => {
              if (!match.includes(']')) {
                return match + ']';
              }
              return match;
            });
            fixed = fixed.replace(/(\{[^\}]*)$/gm, (match) => {
              if (!match.includes('}')) {
                return match + '}';
              }
              return match;
            });
          }
        }
        
        // Исправляем проблемы с кавычками в названиях
        // Заменяем неправильные кавычки на правильные
        fixed = fixed.replace(/[""]/g, '"').replace(/['']/g, "'");
        
        // Удаляем пустые строки в начале и конце
        fixed = fixed.trim();
        
        return fixed;
      };

      // Извлекаем код в зависимости от типа диаграммы
      if (isMermaid) {
        // Извлекаем код Mermaid
        const mermaidMatch = responseText.match(/```mermaid\s*\n([\s\S]*?)\n```/i) ||
                           responseText.match(new RegExp(`${mermaidDiagramType}\\s*\\n([\\s\\S]*?)(?=\\n\`\`\`|$)`, 'i'));
        
        let mermaidCode = '';
        if (mermaidMatch) {
          mermaidCode = mermaidMatch[1].trim();
          
          // Применяем постобработку для исправления ошибок
          mermaidCode = fixMermaidCode(mermaidCode, mermaidDiagramType);
          
          // Для MindMap применяем дополнительную обработку отступов
          if (mermaidDiagramType === 'mindmap' && (diagramType === 'MindMapMax' || diagramType === 'MindMapMermaid')) {
            mermaidCode = fixMindMapIndentation(mermaidCode);
          }
        } else {
          // Fallback: создаем базовую Mermaid диаграмму в зависимости от типа
          if (mermaidDiagramType === 'mindmap') {
            const rootNode = objectDescription.split(' ')[0] || 'Корневой узел';
            mermaidCode = `mindmap
  root((${rootNode}))
    Подтема 1
      Деталь 1.1
    Подтема 2
      Деталь 2.1`;
          } else if (mermaidDiagramType === 'flowchart' || mermaidDiagramType === 'graph') {
            const nodeName = objectDescription.split(' ')[0] || 'Элемент';
            mermaidCode = `${mermaidDiagramType} TD
    A[${nodeName}]
    B[Подэлемент 1]
    C[Подэлемент 2]
    A --> B
    A --> C`;
          } else if (mermaidDiagramType === 'pie') {
            mermaidCode = `pie title ${objectDescription.split(' ')[0] || 'Диаграмма'}
    "Элемент 1" : 30
    "Элемент 2" : 50
    "Элемент 3" : 20`;
          } else {
            mermaidCode = `${mermaidDiagramType}\n    ${objectDescription.split(' ')[0] || 'Элемент'}`;
          }
          
          // Применяем постобработку к fallback коду
          mermaidCode = fixMermaidCode(mermaidCode, mermaidDiagramType);
        }

        // Извлекаем глоссарий
        const glossaryMatch = responseText.match(/```json\s*\n([\s\S]*?)\n```/i);
        let glossary: Array<{ element: string; description: string }> = [];
        
        if (glossaryMatch) {
          try {
            glossary = JSON.parse(glossaryMatch[1]);
          } catch (e) {
            console.error('Ошибка парсинга глоссария:', e);
            glossary = [{ element: objectDescription, description: 'Основной объект диаграммы' }];
          }
        } else {
          glossary = [{ element: objectDescription, description: 'Основной объект диаграммы' }];
        }

        // Валидация глоссария
        if (!Array.isArray(glossary)) {
          glossary = [{ element: objectDescription, description: 'Основной объект диаграммы' }];
        }

        return NextResponse.json({
          mermaidCode,
          glossary,
        });
      } else {
        // Извлекаем код PlantUML
        // Для разных типов диаграмм нужны разные теги
        const isMindMap = diagramType === 'MindMap' || diagramType === 'MindMapPlantUML';
        const isJSON = diagramType === 'JSON';
        
        const startTag = isMindMap ? '@startmindmap' : (isJSON ? '@startjson' : '@startuml');
        const endTag = isMindMap ? '@endmindmap' : (isJSON ? '@endjson' : '@enduml');
        
        const plantUmlMatch = responseText.match(/```plantuml\s*\n([\s\S]*?)\n```/i) || 
                             responseText.match(new RegExp(`${startTag}\\s*\\n([\\s\\S]*?)${endTag}`, 'i')) ||
                             responseText.match(/@startuml\s*\n([\s\S]*?)@enduml/i);
        
        let plantUmlCode = '';
        if (plantUmlMatch) {
          plantUmlCode = plantUmlMatch[1].trim();
          
          // Удаляем неправильные теги, если они есть
          plantUmlCode = plantUmlCode.replace(/@startuml\s*/gi, '');
          plantUmlCode = plantUmlCode.replace(/@enduml\s*/gi, '');
          plantUmlCode = plantUmlCode.replace(/@startmindmap\s*/gi, '');
          plantUmlCode = plantUmlCode.replace(/@endmindmap\s*/gi, '');
          plantUmlCode = plantUmlCode.replace(/@startjson\s*/gi, '');
          plantUmlCode = plantUmlCode.replace(/@endjson\s*/gi, '');
          plantUmlCode = plantUmlCode.replace(/mindmap\s*/gi, ''); // Удаляем просто "mindmap" если есть
          plantUmlCode = plantUmlCode.replace(/split\s*/gi, 'fork'); // Заменяем split на fork для Activity
          plantUmlCode = plantUmlCode.replace(/join\s*/gi, 'end fork'); // Заменяем join на end fork для Activity
          
          // Для MindMapPlantUML: добавляем стили для строгих цветов, если их нет
          if (diagramType === 'MindMapPlantUML') {
            // Проверяем, есть ли уже стили
            if (!plantUmlCode.includes('<style>')) {
              const styleBlock = `<style>
mindmapDiagram {
  node {
    BackgroundColor white
    FontColor black
    LineColor #000000
    BorderColor #000000
  }
  rootNode {
    BackgroundColor white
    FontColor black
    LineColor #000000
    BorderColor #000000
  }
  leafNode {
    BackgroundColor white
    FontColor black
    LineColor #666666
    BorderColor #666666
  }
  arrow {
    LineColor #000000
  }
}
</style>
`;
              // Вставляем стили в начало кода (перед содержимым)
              plantUmlCode = styleBlock + plantUmlCode;
            }
          }
          
          // Для Class: исправляем длинные названия классов без пробелов
          if (diagramType === 'Class') {
            // Заменяем длинные слитные русские слова на слова с пробелами в кавычках
            plantUmlCode = plantUmlCode.replace(/class\s+([А-ЯЁ][а-яё]{20,})\s+as\s+(\w+)/gi, (match, className, alias) => {
              // Разбиваем длинное слово на части (каждые 15-20 символов)
              const words = className.match(/.{1,20}/g);
              const spacedName = words ? words.join(' ') : className;
              return `class "${spacedName}" as ${alias}`;
            });
            // Также обрабатываем случаи без "as"
            plantUmlCode = plantUmlCode.replace(/class\s+([А-ЯЁ][а-яё]{20,})\s*{/gi, (match, className) => {
              const words = className.match(/.{1,20}/g);
              const spacedName = words ? words.join(' ') : className;
              return `class "${spacedName}" {`;
            });
          }
          
          // Добавляем правильные теги
          if (!plantUmlCode.includes(startTag)) {
            plantUmlCode = `${startTag}\n` + plantUmlCode;
          }
          if (!plantUmlCode.includes(endTag)) {
            plantUmlCode = plantUmlCode + `\n${endTag}`;
          }
        } else {
          // Если не нашли в markdown, ищем напрямую
          const startIndex = responseText.indexOf(startTag);
          const endIndex = responseText.indexOf(endTag);
          if (startIndex !== -1 && endIndex !== -1) {
            plantUmlCode = responseText.substring(startIndex, endIndex + endTag.length).trim();
          } else {
            // Fallback: создаем базовую диаграмму в зависимости от типа
            if (isMindMap) {
              plantUmlCode = `${startTag}
* ${objectDescription.split(' ')[0]}
** Подтема 1
*** Деталь 1.1
** Подтема 2
${endTag}`;
            } else {
              plantUmlCode = `${startTag}
class ${objectDescription.split(' ')[0]} {
  + описание
}
${endTag}`;
            }
          }
        }

        // Извлекаем глоссарий
        const glossaryMatch = responseText.match(/```json\s*\n([\s\S]*?)\n```/i);
        let glossary: Array<{ element: string; description: string }> = [];
        
        if (glossaryMatch) {
          try {
            glossary = JSON.parse(glossaryMatch[1]);
          } catch (e) {
            console.error('Ошибка парсинга глоссария:', e);
            // Создаем простой глоссарий на основе кода
            glossary = [{ element: objectDescription, description: 'Основной объект диаграммы' }];
          }
        } else {
          // Если глоссарий не найден, создаем базовый
          glossary = [{ element: objectDescription, description: 'Основной объект диаграммы' }];
        }

        // Валидация глоссария
        if (!Array.isArray(glossary)) {
          glossary = [{ element: objectDescription, description: 'Основной объект диаграммы' }];
        }

        return NextResponse.json({
          plantUmlCode,
          glossary,
        });
      }
    } catch (apiError) {
      console.error('Ошибка при вызове Mistral AI API:', apiError);
      return NextResponse.json(
        { error: `Ошибка при генерации диаграммы: ${apiError instanceof Error ? apiError.message : 'Неизвестная ошибка'}` },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error('Ошибка при обработке запроса генерации диаграммы:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Ошибка при обработке запроса' },
      { status: 500 }
    );
  }
}

